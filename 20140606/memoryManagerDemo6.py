#! /usr/bin/env python
# coding:utf-8
# 垃圾回收(garbage collection)

# 从基本原理上讲，当Python的某个对象的引用计数降为0时，说明没有任何引用指向该对象，该对象就成为要被回收的垃圾了。
from sys import getrefcount
a = [1, 2, 3]
del a
try:
	print(getrefcount(a))
except NameError:
	print("NameError:a is not valid")
# del a后，已经没有任何引用指向之前建立的[1，2，3]这个list，用户不能通过任何方式接触或者动用这个对象。这个对象如果继续待在内存里，就成了不健康的脂肪。当垃圾回收启动后，Python扫描到这个引用计数为0的对象，就将它所占据的内存清空。


# 减肥是个昂贵而费力的事情。垃圾回收时，Python不能进行其它的任务。频繁的垃圾回收将大大降低Python的工作效率。如果内存中的对象不多，就没有必要总启动垃圾回收。所以，Python只会在特定条件下，自动启动垃圾回收。当Python运行时，会记录其中分配对象(object allocation)和取消分配对象(object deallocation)的次数。当两者的差值高于某个阈值时，垃圾回收才启动。
# 可以通过gc模块的get_threshold()查看改阈值，通过set_threshold()重置
import gc
print(gc.get_threshold())
# return (700,10,10) #700为垃圾回收启动阈值，后面的两个10为与分代回收相关阈值
# 手动启动垃圾回收：gc.collect()


# 分代回收(generation)
# Python同时采用了分代回收的策略。这一策略的基本假设是，存活时间越久的对象，越不可能在后面的程序中变成垃圾。我们的程序往往会产生大量的对象，许多对象很快产生和消失，但也有一些对象长期被使用。出于信任和效率，对于这样一些“长寿”对象，我们相信它们的用处，所以减少在垃圾回收中扫描它们的频率。
# Python将所有的对象分为0，1，2三代。所有的新建对象都是0代对象。当某一代对象经历过垃圾回收，依然存活，那么它就被归入下一代对象。垃圾回收启动时，一定会扫描所有的0代对象。如果0代经历一定次数垃圾回收，那么就启动对0代和1代的扫描清理。当1代也经历了一定次数的垃圾回收后，那么会启动对0、1、2，即对所有对象进行扫描。
# 这两个次数即上面get_threshold()返回的(700,10,10)返回的两个10.也就时说，每10次0代垃圾回收，会配合一次1代的垃圾回收；而每10次1代垃圾回收，才会有1次的2代垃圾回收。
#调整示例
#set_threshold(700, 10, 5)


# 垃圾回收机制对孤立引用环的回收
# 为了回收孤立的引用环，Python复制每个对象的引用计数，可以记为gc_ref.假设某个对象为i,则该计数为gc_ref_i.Python会遍历所有的对象i,对于每个对象i引用的对象j,将相应的gc_ref_j减1
# 在结束遍历后，gc_ref不为0的对象，和这些对象引用的对象，以及继续更下游引用的对象，需要被保留。而其他的对象则被垃圾回收。 
#孤立引用环一例
a = []
b = [a]
a.append(b)
del a
del b
